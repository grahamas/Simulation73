#+PROPERTY: header-args :results output :results silent :session *julia* :noweb yes
#+OPTIONS: title:nil author:nil date:nil toc:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER_EXTRA: \input{\string~/Dropbox/Tex/standard_preamble.tex}
#+AUTHOR: Graham Smith
#+EMAIL: grahamas@gmail.com
#+TITLE: Fitting the Wilson-Cowan Integro-Differential Equations
#+LATEX_HEADER: \input{\string~/Dropbox/Tex/math_preamble.tex}


* Introduction

Here I will simulate the spatially one-dimensional Wilson-Cowan equations as described in
*************** TODO Cite Wilson, Cowan 1973 paper
*************** END

*************** TODO Figure out citations in org-mode
*************** END

using the Julia.

* Equations

First, let's specify the equations we will be simulating:

\[\begin{align}
\tau_E \partial_t E(x,t) &= -\alpha_E E(x,t) + \beta_E (1 - E(x,t)) \cS_E \left( W_{EE}(X) \conv E(x,t) + W_{EI}(X) \conv I(x,t) + P_E(x,t)\right)\\
\tau_I \partial_t I(x,t) &= -\alpha_I I(x,t) + \beta_I (1 - I(x,t)) \cS_I \left( W_{IE}(X) \conv E(x,t) +  W_{II}(X) \conv I(x,t) + P_I(x,t)\right)
\end{align}\]
*************** TODO Make nonlinearity a mathop
*************** END


though in practice we discretize and turn the convolution into a matrix multiplication (the latter a decision made for the author's understanding rather than for any computational considerations). Suppose we discretize space into $M$ points, so that we can think of $E(\cdot, t)$ as a $M\times 1$ vector. Define $\bA(t)$ as the vertical concatenation of $E(\cdot, t)$ on top of $I(\cdot, t)$ such that $\bA(t)$ is a $2M \times 1$ vector.[fn:1]  Then the equation we actually simulate is

\[\begin{align}
\btau \odot \Delta \bA(t^+) &= -\balpha \odot \bA(t) + \bbeta \odot (1 - \bA(t)) \cS \left( \bW \bA(t) + \bP(t)\right)
\end{align}\]

where $\odot$ is the Hademard (element-wise) product of an appropriately expanded[fn:2] parameter vector, e.g. so that in the first instance, each element of $\bA$ corresponding to an element of $E$ is multiplied by $\tau_E$, and similarly for $I$.

* Simulation
** Overview
The code will proceed as follows

#+BEGIN_SRC julia :noweb no-export :results silent :tangle wilson-cowan.jl
  module WC73
  <<load-modules>>
  <<parameters-loader>>
  <<wc73-definition>>
  <<wc73-solver>>
  <<wc73-analysis>>
  export run_WilsonCowan73_trial
  end
  #<<run-wc73-trial>>

#+END_SRC

See the appendix for helper functions, including parameter loading.

** Imports

#+BEGIN_SRC julia :noweb-ref load-modules :results silent
  using Parameters
  import JSON

  using TensorOperations

  using DifferentialEquations

  ENV["GKSwstype"] = "100" # For headless plotting (on server)
  using Plots; gr()

  import Base.Dates
#+END_SRC

** Define WilsonCowan73
*** Overview
I will relegate the sigmoid and input functions to the appendix. Suffice to say,
the sigmoid is rectified and normed, and the input function is a step function
centered at $x=0$.

#+BEGIN_SRC julia :noweb no-export :noweb-ref wc73-definition :results silent
  <<wc73-types>>
  <<sigmoid>>
  <<stimulus>>
  <<connectivity>>
  <<wc73-constructor>>
  <<wc73-differential>>
#+END_SRC

*** Type aliases (and definition)

#+BEGIN_SRC julia :noweb-ref wc73-types
  const NumType = Float64
  const DistType = NumType
  const TimeType = NumType
  const PopulationParam = RowVector{NumType}
  const ExpandedParam = Array{NumType, 2}
  const ExpandedParamFlat = Array{NumType,1}
  const InteractionTensor = Array{NumType,4}
  const Interaction1DFlat = Array{NumType,2}
  const SpaceState1D = Array{NumType, 2}
  const SpaceState1DFlat = Array{NumType,1}
  const SpaceDim = StepRangeLen{NumType}
  abstract type AbstractMesh end
  @with_kw struct WilsonCowan73Params{InteractionType, ParamType}
    # Explict fields in parameter file
    # May also be given as LaTeX command (e.g. alpha for α)
      α::ParamType     # Weight on homeostatic term
      β::ParamType     # Weight on nonlinear term
      τ::ParamType     # Time constant
      a::ParamType     # Sigmoid steepness
      θ::ParamType     # Sigmoid translation
      r::ParamType     # Refractory period multiplier
    # Other fields in parameter file include
    # :time => {[:N], :extent}
    # :space => {:N, :extent}
    # :stimulus => {:weight, :duration, :strength}
    # :connectivity => {:amplitudes, :spreads}
    # Constructed fields
      W::InteractionType    # Tensor interaction multiplier
      stimulus_fn::Function
      mesh::AbstractMesh
  end
#+END_SRC

*** Constructor for WC73 parameter object

#+BEGIN_SRC julia :noweb-ref wc73-constructor

    function WilsonCowan73Params(p)
        p = deepcopy(p) # to prevent mutation
        npops = length(p[:r])

        space_dims = pop!(p, :space)
        @assert length(space_dims) == 1      # Currently only supports 1D
        mesh = PopMesh(space_dims, npops)
        if ndims(mesh) == 2
            mesh = flatten(mesh)
        end
        #@assert mesh isa FlatMesh

        stimulus_params = expand_params(mesh, pop!(p, :stimulus))
        connectivity_params = expand_params(mesh, pop!(p, :connectivity))
        p = expand_params(mesh, p)

        p[:mesh] = mesh
        p[:stimulus_fn] = make_stimulus_fn(mesh; stimulus_params...)
        p[:W] = sholl_connectivity(mesh, connectivity_params[:amplitudes],
                                   connectivity_params[:spreads])

        return WilsonCowan73Params(; p...)
    end

  function expand_params(mesh::AbstractMesh, dct::T) where T <: Dict
      for (k,v) in dct
          if v isa PopulationParam
              dct[k] = expand_param(mesh, v)
          end
      end
      return dct
  end

#+END_SRC

*** Differential equation definition

#+BEGIN_SRC julia :noweb-ref wc73-differential

  WilsonCowan73!(dA,A::SpaceState1D,p::WilsonCowan73Params{InteractionTensor},t) = begin
      # Use dA as intermediate variable for tensor op since it is preallocated
      @tensor dA[x_tgt, pop_tgt] = p.W[x_tgt, pop_tgt, x_src, pop_src] * A[x_src, pop_src]
      dA .= (-p.α .* A + p.β .* (1 .- A) .* sigmoid_fn(dA + p.stimulus_fn(t), p.a, p.θ)) ./ p.τ
  end

  WilsonCowan73_flat!(dA,A::SpaceState1DFlat,p::WilsonCowan73Params{Interaction1DFlat},t) = begin
      # Use dA as intermediate variable for tensor op since it is preallocated
      dA .= (-p.α .* A + p.β .* (1 .- A) .* sigmoid_fn(p.W*A + p.stimulus_fn(t), p.a, p.θ)) ./ p.τ
  end
#+END_SRC

** WilsonCowan73 Solver

#+BEGIN_SRC julia :noweb-ref wc73-solver

  function solve_WilsonCowan73(; model=nothing, solver=nothing, other...)
      solver_params = deepcopy(Dict{Any,Any}(solver))
      model_params = WilsonCowan73Params(model)

      if model_params isa WilsonCowan73Params{Interaction1DFlat}
          differential_fn = WilsonCowan73_flat!
      else
          differential_fn = WilsonCowan73!
      end

      u0 = zeros(model_params.mesh)
      tspan = (0.0, pop!(solver_params, :T))
      prob::DEProblem = ODEProblem(differential_fn, u0, tspan, model_params)

      if :dt in keys(solver_params)
          solver_params[:alg] = Euler()
          solver_params[:adaptive] = false
      elseif :stiff in keys(solver_params)
          if pop!(solver_params, :stiff) > 0
              solver_params[:alg_hints] = [:stiff]
          end
      end

      if :stiff in keys(solver_params)
          error("Incompatible solver parameters.")
      end

      soln::DESolution = solve(prob; solver_params...)

      return soln
  end

#+END_SRC

** Analysis and Runner
   This code currently only plots.
#+BEGIN_SRC julia :noweb-ref wc73-analysis
  <<file-helpers>>
  <<plotting-helpers>>

    function analyse_WilsonCowan73_solution(soln; analyses=nothing, all_params...)
        dir_name = output_dir_name(; analyses...)
        write_params(dir_name; analyses=analyses, all_params...)
        solution_gif(soln; dir_name=dir_name, analyses[:activity_gif]...)
    end

    function run_WilsonCowan73_trial(json_filename::String)
        all_params = load_WilsonCowan73_parameters(json_filename)
        solution = solve_WilsonCowan73(; all_params...)
        analyse_WilsonCowan73_solution(solution; all_params...)
    end

#+END_SRC

** Run Trial

Then the solution is as simple as
#+BEGIN_SRC julia :noweb-ref run-wc73-trial
run_WilsonCowan73_trial("jl_replicate_neuman.json")
#+END_SRC

#+RESULTS:
: INFO: Saved animation to /home/grahams/Dropbox/Research/simulation-73/solution.gif
: Plots.AnimatedGif("/home/grahams/Dropbox/Research/simulation-73/solution.gif")

* Appendix
** Parameter file reading
Because I originally wrote this in Python, the parameter files are JSON.
#+BEGIN_SRC julia :noweb-ref parameters-loader :results silent
  function convert_py(val::Number)
      float(val)
  end

  function convert_py(a::T) where T <: Array
      if a[1] isa Array # eltype gives Any, for some reason
          return convert_py.(hcat(a...))'
      elseif a[1] isa Dict
          return convert_py.(a)
      elseif a[1] isa Number
          return convert_py.(vcat(a...))'
      else
          error("Unsupported parse input array of eltype $(typeof(a[1]))")
      end
  end

  convert_py(val::String) = val

  function convert_py(d::T) where T <: Dict
      # TODO: Find package that does this...
      unicode_dct = Dict(:alpha=>:α, :beta=>:β, :tau=>:τ, :theta=>:θ)
      function convert_pykey(k_sym::Symbol)
          if k_sym in keys(unicode_dct)
              return unicode_dct[k_sym]
          else
              return k_sym
          end
      end
      convert_pykey(k::String) = (convert_pykey ∘ Symbol)(k)

      return Dict(convert_pykey(k) => convert_py(v) for (k,v) in d)
  end


  function load_WilsonCowan73_parameters(json_filename::String)
      # Parse JSON with keys as symbols.
      param_dct = (convert_py ∘ JSON.parsefile)(json_filename)
      return param_dct
  end

#+END_SRC

#+RESULTS:
#+begin_example
convert_py (generic function with 1 method)

parse_pykey (generic function with 1 method)

parse_pyvalue (generic function with 1 method)

parse_pyarray (generic function with 1 method)

parse_py_dict (generic function with 1 method)

load_WilsonCowan73_parameters (generic function with 1 method)
#+end_example

** Sigmoid

The sigmoid function is defined
\[\begin{align}
\sigmoid(x) = \frac{1}{1 + \exp(-a(x - \theta))}
\end{align}\]
where $a$ describes the slope's steepness and $\theta$ describes translation of the slope's center away from zero.

The current definition uses a macro. It is not clear that this is necessary, nor even advisable. However, the ParameterizedFunction automatically calculates useful quantities like the Jacobian, including with respect to the parameters themselves, and I thought I'd see if this works better. Initially I was using a provided macro that didn't seem to like function calls, so this macro was necessary. Now I doubt it's necessary and I'll probably run some tests to see if there's any performance difference in the DifferentialEquations solve.

#+BEGIN_SRC julia :noweb-ref sigmoid :results silent
  function simple_sigmoid_fn(x, a, theta)
      return @. (1 / (1 + exp(-a * (x - theta))))
  end

  function sigmoid_fn(x, a, theta)
      return max.(0, simple_sigmoid_fn(x, a, theta) .- simple_sigmoid_fn(0, a, theta))
  end
#+END_SRC

** Connectivity
#+BEGIN_SRC julia :noweb-ref connectivity :results silent
<<connectivity-mesh>>
<<connectivity-distance-matrix>>
<<connectivity-sholl-matrix>>
<<connectivity-sholl>>
#+END_SRC

#+BEGIN_SRC julia :noweb-ref connectivity-test
<<connectivity-mesh-test>>
<<connectivity-distance-matrix-test>>
<<connectivity-sholl-matrix-test>>
<<connectivity-sholl-tensor-test>>
#+END_SRC
*** Sholl's exponential decay
We use an exponential connectivity function, inspired both by Sholl's
experimental work, and by certain theoretical considerations.
#+BEGIN_SRC julia :noweb-ref connectivity-sholl-matrix :results silent
  function sholl_matrix(amplitude::NumType, spread::NumType,
                        dist_mx::Array{NumType,2}, step_size::NumType)
      conn_mx = @. amplitude * step_size * exp(
          -abs(dist_mx / spread)
      ) / (2 * spread)
      return conn_mx
  end
#+END_SRC
The interaction between two populations is entirely characterized by this
function and its two parameters: the amplitude (weight) and the spread
(σ). The spatial step size is also a factor, but as a computational concern
rather than a fundamental one.
**** Test
#+BEGIN_SRC julia :noweb-ref test-connectivity-sholl-matrix

#+END_SRC

*** Make mesh of space

#+BEGIN_SRC julia :noweb-ref connectivity-mesh :results silent

  struct SpaceMesh <: AbstractMesh
      dims::Array{SpaceDim}
  end
  struct PopMesh <: AbstractMesh
      space::SpaceMesh
      n_pops::Integer
  end
  struct FlatMesh <: AbstractMesh
      pop_mesh::PopMesh
      FlatMesh(mesh) = ndims(mesh) != 2 ? error("cannot flatten >1D mesh.") : new(mesh)
  end
  flatten(mesh::PopMesh) = FlatMesh(mesh)
  unflatten(mesh::FlatMesh) = mesh.pop_mesh

  function SpaceMesh(dim_dcts::Array{T}) where T <: Dict
      dims = Array{StepRangeLen}(length(dim_dcts))
      for (i, dim) in enumerate(dim_dcts)
          extent::NumType = dim[:extent]
          N::Integer = dim[:N]
          dims[i] = linspace(-(extent/2), (extent/2), N)
      end
      SpaceMesh(dims)
  end
  function PopMesh(dim_dcts::Array{T}, n_pops::Integer) where T <: Dict
      PopMesh(SpaceMesh(dim_dcts),n_pops)
  end

  import Base: size, ndims, zeros
  function size(mesh::SpaceMesh)
      return length.(mesh.dims)
  end
  function size(mesh::PopMesh)
      return (size(mesh.space)..., mesh.n_pops)
  end
  function size(mesh::FlatMesh)
      return size(mesh.pop_mesh)[1] * mesh.n_pops
  end
  function ndims(mesh::AbstractMesh)
      return length(size(mesh))
  end

  function coords(mesh::SpaceMesh)
      @assert ndims(mesh) == 1
      return mesh.dims[1]
  end
  function coords(mesh::PopMesh)
      @assert ndims(mesh) == 2
      return repeat(coords(mesh.space), outer=(1, mesh.n_pops))
  end
  function coords(mesh::FlatMesh)
      return repeat(coords(mesh.pop_mesh.space), outer=mesh.pop_mesh.n_pops)
  end
  function zeros(mesh::AbstractMesh)
      zeros(coords(mesh))
  end
  function expand_param(mesh::PopMesh, param::RowVector)::ExpandedParam
      space_dims = size(mesh)[1:end-1]
      return repeat(param, inner=(space_dims..., 1))
  end
  function expand_param(mesh::FlatMesh, param::RowVector)::ExpandedParamFlat
      return expand_param(mesh.pop_mesh, param)[:]
  end


#+END_SRC

*** Make matrix of all inter-point distances

#+BEGIN_SRC julia :noweb-ref connectivity-distance-matrix :results silent
  function distance_matrix(xs::SpaceDim)
      # aka Hankel, but that method isn't working in SpecialMatrices
      distance_mx = zeros(eltype(xs), length(xs), length(xs))
      for i in range(1, length(xs))
          distance_mx[:, i] = abs.(xs - xs[i])
      end
      return distance_mx'
  end
#+END_SRC

*** Join Sholl matrices into complete interaction tensor

#+BEGIN_SRC julia :noweb-ref connectivity-sholl :results silent
    function sholl_connectivity(mesh::PopMesh, W::Array{NumType,2}, Σ::Array{NumType,2})::InteractionTensor
        xs = mesh.space.dims[1]
        N_x = length(xs)
        N_pop = size(W)[1]
        conn_tn = zeros(N_x, N_pop, N_x, N_pop)
        for tgt_pop in range(1,N_pop)
            for src_pop in range(1,N_pop)
                conn_tn[:, tgt_pop, :, src_pop] .= sholl_matrix(W[tgt_pop, src_pop],
                              Σ[tgt_pop, src_pop], distance_matrix(xs), step(xs))
            end
        end
        return conn_tn
    end
    <<connectivity-flatten-sholl>>
#+END_SRC

**** Flatten 1-space-D Sholl tensor
In the two population case, flattening the tensor and using matrix
multiplication is 3x faster.
#+BEGIN_SRC julia :noweb-ref connectivity-flatten-sholl
  function sholl_connectivity(mesh::FlatMesh, args...)
      sholl_connectivity(unflatten(mesh), args...) |> flatten_sholl
  end
  function flatten_sholl(tensor)::Interaction1DFlat
      N_x, N_p = size(tensor)[1:2]
      @assert N_p < N_x
      @assert size(tensor) == (N_x, N_p, N_x, N_p)
      flat = zeros(eltype(tensor), N_x*N_p, N_x*N_p)
      for i in 1:N_p
          for j in 1:N_p
              flat[(1:N_x)+((i-1)*N_x), (1:N_x)+((j-1)*N_x)] = tensor[:,i,:,j]
          end
      end
      return flat
  end
#+END_SRC

** Stimulus

The stimulus returned is a function of time.

#+BEGIN_SRC julia :noweb-ref stimulus :results silent
  function make_stimulus_fn( mesh; name=nothing, arguments...)
      stimulus_factories = Dict(
          "smooth_bump" => smooth_bump_factory,
          "sharp_bump" => sharp_bump_factory
      )
      return stimulus_factories[name](; coords=coords(mesh), arguments...)
  end
#+END_SRC

*** Smooth bump (like Gaussian)
The smooth bump is a smooth approximation of the sharp impulse defined
elsewhere. It is smooth in both time and space. It is constructed essentially
from three sigmoids: Two coplanar in space, and one orthogonal to those in
time. The two in space describe a bump: up one sigmoid, then down a negative
sigmoid. The one in time describes the decay of that bump.

This stimulus has the advantages of being 1) differentiable, and 2) more
realistic. The differentiabiilty may be useful for the automatic solvers that
Julia has, which can try to automatically differentiate the mutation function
in order to improve the solving.
#+BEGIN_SRC julia :noweb-ref stimulus :results silent
  function make_smooth_bump_frame(coords::Array{DistType}, width::DistType, strength::NumType, steepness::NumType)
      @. strength * (simple_sigmoid_fn(coords, steepness, -width/2) - simple_sigmoid_fn(coords, steepness, width/2))
  end

  function smooth_bump_factory(; coords=nothing,
                               width=nothing, strength=nothing, duration=nothing,
                               steepness=nothing)
      # WARNING: Defaults are ugly; Remove when possible.
      on_frame = make_smooth_bump_frame(coords, width, strength, steepness)
      return (t) -> @. on_frame * (1 - simple_sigmoid_fn(t, steepness, duration))
  end
#+END_SRC

*** Sharp bump (Heaviside)
The "sharp bump" is the usual theoretical impulse: Binary in both time and
space. On, then off.
#+BEGIN_SRC julia :noweb-ref stimulus :results silent
  function make_sharp_bump_frame(coords::Array{DistType,2}, width::DistType, strength::NumType)
      frame = zeros(coords)
      mid_point = 0     # half length, half width
      half_width = width / 2      # using truncated division
      xs = coords[:,1]   # Assumes all pops have same coords
      start_dx = find(xs .>= mid_point - half_width)[1]
      stop_dx = find(xs .<= mid_point + half_width)[end]
      frame[start_dx:stop_dx,:] = strength
      return frame
  end
  function sharp_bump_factory(; coords=nothing, width=nothing, strength=nothing, duration=nothing)
          # WARNING: Defaults are ugly; Remove when possible.
      on_frame = make_sharp_bump_frame(coords, width, strength)
      off_frame = zeros(on_frame)
      return (t) -> (t <= duration) ? on_frame : off_frame
  end
#+END_SRC
*** Visualisation function
Old code, not currently in use.

Plots the step stimulus in time and space.
#+BEGIN_SRC julia :noweb-ref visualise-step-stimulus :results graphics
  function visualize_step_stimulus(; N_x=500, x_extent=3, width=2, strength=3, duration=4, N_t=700,
  let N_x=500, x_extent=3, width=2, strength=3, duration=4, N_t=700, t_extent=7
      global xs = linspace(-x_extent, x_extent, N_x)
      global on_frame = make_input_frame(xs, width, strength)
      global ts = linspace(0, t_extent, N_t)
      global val = zeros(Float64, N_x, N_t)
      for (i,t) in enumerate(ts)
	  val[:,i] = @step_input(t, on_frame, duration)
      end
  end
  x_grid = repeat(xs, outer=(1, length(ts)));
  t_grid = repeat(ts', outer=(length(xs),1));
  #pyplot()
  #Plots.surface(x_grid, t_grid, val)
  gr()
  Plots.surface(val)
#+END_SRC

** Plotting
Plotting helper functions.
#+BEGIN_SRC julia :noweb-ref plotting-helpers

  function solution_gif(soln; dir_name="", file_name="solution.gif",
			disable=0, subsample=1, fps=15)
      if disable != 0
	  return
      end
      max_activity = maximum(soln, (1,2,3))[1] # I don't know why this index is here.
      min_activity = minimum(soln, (1,2,3))[1]
      subsample = floor(Int, subsample)
      anim = @animate for i in 1:subsample:length(soln.t)
	  plot([soln[:,1,i], soln[:,2,i]], ylim=(min_activity, max_activity), title="t=$(soln.t[i])")
      end
      save_path = joinpath(dir_name, file_name)
      @safe_write(save_path, gif(anim, save_path, fps=fps))
  end

#+END_SRC
** File output
Helper functions for writing out results.
#+BEGIN_SRC julia :noweb-ref file-helpers

  macro safe_write(path, writer)
      quote
	  if !(isfile($(esc(path))))
	      $(esc(writer))
	  else
	      warn("Tried to write existing file: $(esc(path))")
	  end
      end
  end

  function output_dir_name(; root=nothing, simulation_name=nothing, other...)
      now = Dates.format(Dates.now(), "yyyy-mm-ddTHH:MM:SS.s")
      dir_name = joinpath(root, simulation_name, now)
      mkpath(dir_name)
      return dir_name
  end

  function write_params(dir_name; params...)
      save_path = joinpath(dir_name, "parameters.json")
      @safe_write(save_path, write(save_path, JSON.json(params)))
  end

#+END_SRC
* Footnotes

[fn:2] Under the tensor notation, this is merely broadcasting.

[fn:1] It will be more natural (and likely extensible) to concatenate along the second dimension, as done in the previous Python implementation. Here I restrict myself to vertical concatenation to avoid muddling things with the introduction of tensor multiplication and Einstein notation.
