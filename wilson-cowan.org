#+PROPERTY: header-args :results output silent :session *julia* :noweb yes
#+OPTIONS: title:nil author:nil date:nil toc:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER_EXTRA: \input{\string~/Dropbox/Tex/standard_preamble.tex}
#+AUTHOR: Graham Smith
#+EMAIL: grahamas@gmail.com
#+TITLE: Fitting the Wilson-Cowan Integro-Differential Equations
#+LATEX_HEADER: \input{\string~/Dropbox/Tex/math_preamble.tex}


* Introduction

Here I will simulate the spatially one-dimensional Wilson-Cowan equations as described in
*************** TODO Cite Wilson, Cowan 1973 paper
*************** END

*************** TODO Figure out citations in org-mode
*************** END

using the Julia.

* Equations

First, let's specify the equations we will be simulating:

\[\begin{align}
\tau_E \partial_t E(x,t) &= -\alpha_E E(x,t) + \beta_E (1 - E(x,t)) \cS_E \left( W_{EE}(X) \conv E(x,t) + W_{EI}(X) \conv I(x,t) + P_E(x,t)\right)\\
\tau_I \partial_t I(x,t) &= -\alpha_I I(x,t) + \beta_I (1 - I(x,t)) \cS_I \left( W_{IE}(X) \conv E(x,t) +  W_{II}(X) \conv I(x,t) + P_I(x,t)\right)
\end{align}\]
*************** TODO Make nonlinearity a mathop
*************** END


though in practice we discretize and turn the convolution into a matrix multiplication (the latter a decision made for the author's understanding rather than for any computational considerations). Suppose we discretize space into $M$ points, so that we can think of $E(\cdot, t)$ as a $M\times 1$ vector. Define $\bA(t)$ as the vertical concatenation of $E(\cdot, t)$ on top of $I(\cdot, t)$ such that $\bA(t)$ is a $2M \times 1$ vector.[fn:1]  Then the equation we actually simulate is

\[\begin{align}
\btau \odot \Delta \bA(t^+) &= -\balpha \odot \bA(t) + \bbeta \odot (1 - \bA(t)) \cS \left( \bW \bA(t) + \bP(t)\right)
\end{align}\]

where $\odot$ is the Hademard (element-wise) product of an appropriately expanded[fn:2] parameter vector, e.g. so that in the first instance, each element of $\bA$ corresponding to an element of $E$ is multiplied by $\tau_E$, and similarly for $I$.

* Simulation
** Overview
The code will proceed as follows

#+BEGIN_SRC julia :noweb no-export :results silent :tangle yes
 <<load-modules>>
 <<parameters-loader>>
 <<wc73-definition>>
 <<wc73-solver>>
 <<wc73-analysis>>
 <<run-wc73-trial>>
#+END_SRC

See the appendix for helper functions, including parameter loading.

** Imports

#+BEGIN_SRC julia :noweb-ref load-modules :results silent
  using Parameters
  import JSON

  using TensorOperations

  using DifferentialEquations

  using Plots; gr()

  import Base.Dates
#+END_SRC

** Define WilsonCowan73

I will relegate the sigmoid and input functions to the appendix. Suffice to say,
the sigmoid is rectified and normed, and the input function is a step function
centered at $x=0$.

#+BEGIN_SRC julia :noweb no-export :noweb-ref wc73-definition :results silent
  <<define-wc73-types>>
  <<define-sigmoid>>
  <<define-stimulus>>
  <<define-connectivity>>
  <<define-wc73-constructor>>
  <<define-wc73-differential>>
#+END_SRC

#+BEGIN_SRC julia :noweb-ref define-wc73-types
  const NumType = Float64
  const DistType = NumType
  const TimeType = NumType
  const PopulationParam = RowVector{NumType}
  const InteractionParam = Array{NumType,4} # TODO: Change to matmul (dim=2)
  const SpaceState = Array{NumType,2}
  const SpaceMesh = StepRangeLen{NumType}
  @with_kw struct WilsonCowan73Params
    # Explict fields in parameter file
    # May also be given as LaTeX command (e.g. alpha for α)
      α::PopulationParam     # Weight on homeostatic term
      β::PopulationParam     # Weight on nonlinear term
      τ::PopulationParam     # Time constant
      a::PopulationParam     # Sigmoid steepness
      θ::PopulationParam     # Sigmoid translation
      r::PopulationParam     # Refractory period multiplier
    # Other fields in parameter file include
    # :time => {[:N], :extent}
    # :space => {:N, :extent}
    # :stimulus => {:weight, :duration, :strength}
    # :connectivity => {:amplitudes, :spreads}
    # Constructed fields
      W::InteractionParam    # Tensor interaction multiplier
      stimulus_fn::Function
      dims::Tuple
  end

#+END_SRC

#+BEGIN_SRC julia :noweb-ref define-wc73-constructor

  function WilsonCowan73Params(p)
      p = deepcopy(p) # to prevent mutation
      n_pops = length(p[:r])

      space_params = pop!(p, :space)
      xs = make_mesh(space_params)

      p[:dims] = (size(xs)..., n_pops)

      stimulus_params = pop!(p, :stimulus)
      stimulus_params[:xs] = xs
      stimulus_params[:n_pops] = n_pops
      p[:stimulus_fn] = make_stimulus_fn(; stimulus_params...)

      connectivity_params = pop!(p, :connectivity)
      p[:W] = sholl_tensor(xs, connectivity_params[:amplitudes],
                           connectivity_params[:spreads])
      return WilsonCowan73Params(; p...)
  end

#+END_SRC

#+BEGIN_SRC julia :noweb-ref define-wc73-differential

  WilsonCowan73!(dA,A::SpaceState,p::WilsonCowan73Params,t) = begin
      # Use dA as intermediate variable for tensor op since it is preallocated
      @tensor dA[x_tgt, pop_tgt] = p.W[x_tgt, x_src, pop_tgt, pop_src] * A[x_src, pop_src]
      dA .= (-p.α .* A + p.β .* (1 .- A) .* sigmoid_fn(dA + p.stimulus_fn(t), p.a, p.θ)) ./ p.τ
  end
#+END_SRC

** WilsonCowan73 Solver

#+BEGIN_SRC julia :noweb-ref wc73-solver

  function solve_WilsonCowan73(; model=nothing, solver=nothing, other...)
      solver_params = deepcopy(Dict{Any,Any}(solver))
      model_params = WilsonCowan73Params(model)

      u0 = zeros(NumType, model_params.dims)
      tspan = (0.0, pop!(solver_params, :T))
      prob::DEProblem = ODEProblem(WilsonCowan73!, u0, tspan, model_params)

      if :dt in keys(solver_params)
          solver_params[:alg] = Euler()
          solver_params[:adaptive] = false
      elseif :stiff in keys(solver_params)
          if pop!(solver_params, :stiff) > 0
              solver_params[:alg_hints] = [:stiff]
          end
      end

      if :stiff in keys(solver_params)
          error("Incompatible solver parameters.")
      end

      soln::DESolution = solve(prob; solver_params...)

      return soln
  end

#+END_SRC

** Analysis and Runner
   This code currently only plots.
#+BEGIN_SRC julia :noweb-ref wc73-analysis
  <<file-helpers>>
  <<plotting-helpers>>

    function analyse_WilsonCowan73_solution(soln; analyses=nothing, all_params...)
        dir_name = output_dir_name(; analyses...)
        write_params(dir_name; analyses=analyses, all_params...)
        solution_gif(soln; dir_name=dir_name, analyses[:activity_gif]...)
    end

    function run_WilsonCowan73_trial(json_filename::String)
        all_params = load_WilsonCowan73_parameters(json_filename)
        solution = solve_WilsonCowan73(; all_params...)
        analyse_WilsonCowan73_solution(solution; all_params...)
    end

#+END_SRC

** Run Trial

Then the solution is as simple as
#+BEGIN_SRC julia :noweb-ref run-wc73-trial
run_WilsonCowan73_trial("jl_replicate_neuman.json")
#+END_SRC

#+RESULTS:
: INFO: Saved animation to /home/grahams/Dropbox/Research/simulation-73/solution.gif
: Plots.AnimatedGif("/home/grahams/Dropbox/Research/simulation-73/solution.gif")

* Appendix
** Parameter file reading
Because I originally wrote this in Python, the parameter files are JSON.
#+BEGIN_SRC julia :noweb-ref parameters-loader :results silent
  function convert_py(val)
      if isa(val, Number)
	  return float(val)
      else
	  return val
      end
  end

  function parse_pyarray(a)
      if isa(a[1], Array)
	  return convert_py.(hcat(a...))'
      else
	  return convert_py.(vcat(a...))'
      end
  end

  function parse_pydict(d)
      function parse_pykey(k)
	  unicode_dct = Dict(:alpha=>:α, :beta=>:β, :tau=>:τ, :theta=>:θ)
	  k_sym = Symbol(k)
	  if k_sym in keys(unicode_dct)
	      return unicode_dct[k_sym]
	  else
	      return k_sym
	  end
      end

      function parse_pyvalue(v)
	  if isa(v, Dict)
	      return parse_pydict(v)
	  elseif isa(v, Array)
	      # Assumes arrays only contain numbers
	      return parse_pyarray(v)
	  else
	      return convert_py(v)
	  end
      end

      return Dict(parse_pykey(k) => parse_pyvalue(v) for (k,v) in d)
  end


  function load_WilsonCowan73_parameters(json_filename::String)
      # Parse JSON with keys as symbols.
      param_dct = (parse_pydict ∘ JSON.parsefile)(json_filename)
      return param_dct
  end

#+END_SRC

#+RESULTS:
#+begin_example
convert_py (generic function with 1 method)

parse_pykey (generic function with 1 method)

parse_pyvalue (generic function with 1 method)

parse_pyarray (generic function with 1 method)

parse_py_dict (generic function with 1 method)

load_WilsonCowan73_parameters (generic function with 1 method)
#+end_example

** Sigmoid

The sigmoid function is defined
\[\begin{align}
\sigmoid(x) = \frac{1}{1 + \exp(-a(x - \theta))}
\end{align}\]
where $a$ describes the slope's steepness and $\theta$ describes translation of the slope's center away from zero.

The current definition uses a macro. It is not clear that this is necessary, nor even advisable. However, the ParameterizedFunction automatically calculates useful quantities like the Jacobian, including with respect to the parameters themselves, and I thought I'd see if this works better. Initially I was using a provided macro that didn't seem to like function calls, so this macro was necessary. Now I doubt it's necessary and I'll probably run some tests to see if there's any performance difference in the DifferentialEquations solve.

#+BEGIN_SRC julia :noweb-ref define-sigmoid :results silent
  macro simple_sigmoid(x, a, theta)
      return :(@. 1 / (1 + exp(-$(esc(a)) * ($(esc(x)) - $(esc(theta))))))
  end

  macro sigmoid(x, a, theta)
       return :(@. max(0, @simple_sigmoid($(esc(x)), $(esc(a)), $(esc(theta))) - @simple_sigmoid(0, $(esc(a)), $(esc(theta)))))
  end

  function simple_sigmoid_fn(x, a, theta)
      return @. (1 / (1 + exp(-a * (x - theta))))
  end

  function sigmoid_fn(x, a, theta)
      return max.(0, simple_sigmoid_fn(x, a, theta) .- simple_sigmoid_fn(0, a, theta))
  end
#+END_SRC

** Connectivity

We use an exponential connectivity function, inspired both by Sholl's experimental work, and by certain theoretical considerations.

#+BEGIN_SRC julia :noweb-ref define-connectivity :results silent
  function make_mesh(dim_params)::SpaceMesh
      extent::NumType = dim_params[:extent]
      N::Integer = dim_params[:N]

      return linspace(-extent, extent, N)
  end


  function distance_matrix(xs::SpaceMesh)
      # aka Hankel, but that method isn't working in SpecialMatrices
      distance_mx = zeros(eltype(xs), length(xs), length(xs))
      for i in range(1, length(xs))
	  distance_mx[:, i] = abs.(xs - xs[i])
      end
      return distance_mx'
  end

  function sholl_matrix(amplitude::NumType, spread::NumType, dist_mx::Array{NumType,2}, step_size::NumType)
      conn_mx = @. amplitude * step_size * exp(
	  -abs(dist_mx / spread)
      ) / (2 * spread)
      return conn_mx
  end

  function sholl_tensor(xs::SpaceMesh, W::Array{NumType,2}, Σ::Array{NumType,2})
      N_x = length(xs)
      N_pop = size(W)[1]
      conn_tn = zeros(N_x, N_x, N_pop, N_pop)
      for tgt_pop in range(1,N_pop)
	  for src_pop in range(1,N_pop)
	      conn_tn[:, :, tgt_pop, src_pop] .= sholl_matrix(W[tgt_pop, src_pop],
			    Σ[tgt_pop, src_pop], distance_matrix(xs), step(xs))
	  end
      end
      return conn_tn
  end

#+END_SRC

** Stimulus

*************** TODO Experiment with constant steep_a, both numerically and syntactically
*************** END

As mentioned above, the ParameterizedFunction does some automatic differentiation. In deference to this (though without testing in the first place...) I've replaced the usual heaviside step function with the sigmoid approximation. A value of 10 was chosen arbitrarily as a relatively steep slope.

#+BEGIN_SRC julia :noweb-ref define-stimulus :results silent
  macro step_stimulus(t_sym, on_frame_sym, duration_sym, steepness_sym)
     return :(@. $(esc(on_frame_sym)) * (1-@simple_sigmoid($(esc(t_sym)), $(esc(steepness_sym)), $(esc(duration_sym)))))
  end

  function make_smooth_bump_frame(xs, n_pops::Integer,
					   width::DistType, strength::NumType,
					   steepness::NumType)
      one_pop_frame = @. strength * (simple_sigmoid_fn(xs, steepness, -width/2) - simple_sigmoid_fn(xs, steepness, width/2))
      return repeat(one_pop_frame, outer=(1,n_pops))
  end

  function smooth_bump_factory(; xs=nothing, n_pops=nothing,
			       width=nothing, strength=nothing, duration=nothing,
			       steepness=nothing)
      # WARNING: Defaults are ugly; Remove when possible.
      on_frame = make_smooth_bump_frame(xs, n_pops, width, strength, steepness)
      return (t) -> @. on_frame * (1 - simple_sigmoid_fn(t, steepness, duration))
  end


  function make_sharp_bump_frame(xs, n_pops::Integer,
					  width::DistType, strength::NumType)
      frame = zeros(NumType, size(xs)..., n_pops)
      mid_point = 0     # half length, half width
      half_width = width / 2      # using truncated division
      start_dx = find(xs .>= mid_point - half_width)[1]
      stop_dx = find(xs .<= mid_point + half_width)[end]
      frame[start_dx:stop_dx,:] = strength
      return frame
  end
  function sharp_bump_factory(; xs=nothing, n_pops=nothing,
			      width=nothing, strength=nothing, duration=nothing)
	  # WARNING: Defaults are ugly; Remove when possible.
      on_frame = make_sharp_bump_frame(xs, n_pops, width, strength)
      off_frame = zeros(on_frame)
      return (t) -> (t <= duration) ? on_frame : off_frame
  end

  function make_stimulus_fn(; name=nothing, arguments...)
      stimulus_factories = Dict(
	  "smooth_bump" => smooth_bump_factory,
	  "sharp_bump" => sharp_bump_factory
      )
      return stimulus_factories[name](; arguments...)
  end
#+END_SRC

#+BEGIN_SRC julia :noweb-ref visualise-step-stimulus :results graphics
  function visualize_step_stimulus(; N_x=500, x_extent=3, width=2, strength=3, duration=4, N_t=700,
  let N_x=500, x_extent=3, width=2, strength=3, duration=4, N_t=700, t_extent=7
      global xs = linspace(-x_extent, x_extent, N_x)
      global on_frame = make_input_frame(xs, width, strength)
      global ts = linspace(0, t_extent, N_t)
      global val = zeros(Float64, N_x, N_t)
      for (i,t) in enumerate(ts)
	  val[:,i] = @step_input(t, on_frame, duration)
      end
  end
  x_grid = repeat(xs, outer=(1, length(ts)));
  t_grid = repeat(ts', outer=(length(xs),1));
  #pyplot()
  #Plots.surface(x_grid, t_grid, val)
  gr()
  Plots.surface(val)
#+END_SRC

** Plotting
Plotting helper functions.
#+BEGIN_SRC julia :noweb-ref plotting-helpers

  function solution_gif(soln; dir_name="", file_name="solution.gif",
			disable=0, subsample=1, fps=15)
      if disable != 0
	  return
      end
      max_activity = maximum(soln, (1,2,3))[1] # I don't know why this index is here.
      min_activity = minimum(soln, (1,2,3))[1]
      print(size(soln))
      anim = @animate for i in 1:length(soln.t)
	  plot([soln[:,1,i], soln[:,2,i]], ylim=(min_activity, max_activity), title="t=$(soln.t[i])")
      end
      save_path = joinpath(dir_name, file_name)
      @safe_write(save_path, gif(anim, save_path, fps=fps))
  end

#+END_SRC
** File output
Helper functions for writing out results.
#+BEGIN_SRC julia :noweb-ref file-helpers

  macro safe_write(path, writer)
      quote
	  if !(isfile($(esc(path))))
	      $(esc(writer))
	  else
	      warn("Tried to write existing file: $(esc(path))")
	  end
      end
  end

  function output_dir_name(; root=nothing, simulation_name=nothing, other...)
      now = Dates.format(Dates.now(), "yyyy-mm-ddTHH:MM:SS.s")
      dir_name = joinpath(root, simulation_name, now)
      mkpath(dir_name)
      return dir_name
  end

  function write_params(dir_name; params...)
      save_path = joinpath(dir_name, "parameters.json")
      @safe_write(save_path, write(save_path, JSON.json(params)))
  end

#+END_SRC
* Footnotes

[fn:2] Under the tensor notation, this is merely broadcasting.

[fn:1] It will be more natural (and likely extensible) to concatenate along the second dimension, as done in the previous Python implementation. Here I restrict myself to vertical concatenation to avoid muddling things with the introduction of tensor multiplication and Einstein notation.
