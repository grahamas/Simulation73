#+PROPERTY: header-args :results output :results silent :session *julia* :noweb yes
#+OPTIONS: title:nil author:nil date:nil toc:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER_EXTRA: \input{\string~/Dropbox/Tex/standard_preamble.tex}
#+AUTHOR: Graham Smith
#+EMAIL: grahams@uchicago.edu
#+TITLE: Numerically Solving the Wilson-Cowan Integro-Differential Equation
#+LATEX_HEADER: \input{\string~/Dropbox/Tex/math_preamble.tex}


* Introduction

Here I will simulate the spatially one-dimensional Wilson-Cowan equations as described in
*************** TODO Cite Wilson, Cowan 1973 paper
*************** END

*************** TODO Figure out citations in org-mode
*************** END

using the Julia.

** Equations

First, let's specify the equations we will be simulating:

\[\begin{align}
\tau_E \partial_t E(x,t) &= -\alpha_E E(x,t) + \beta_E (1 - E(x,t)) \cS_E \left( W_{EE}(X) \conv E(x,t) + W_{EI}(X) \conv I(x,t) + P_E(x,t)\right)\\
\tau_I \partial_t I(x,t) &= -\alpha_I I(x,t) + \beta_I (1 - I(x,t)) \cS_I \left( W_{IE}(X) \conv E(x,t) +  W_{II}(X) \conv I(x,t) + P_I(x,t)\right)
\end{align}\]
*************** TODO Make nonlinearity a mathop
*************** END


though in practice we discretize and turn the convolution into a matrix multiplication (the latter a decision made for the author's understanding rather than for any computational considerations). Suppose we discretize space into $M$ points, so that we can think of $E(\cdot, t)$ as a $M\times 1$ vector. Define $\bA(t)$ as the vertical concatenation of $E(\cdot, t)$ on top of $I(\cdot, t)$ such that $\bA(t)$ is a $2M \times 1$ vector.[fn:1]  Then the equation we actually simulate is

\[\begin{align}
\btau \odot \Delta \bA(t^+) &= -\balpha \odot \bA(t) + \bbeta \odot (1 - \bA(t)) \cS \left( \bW \bA(t) + \bP(t)\right)
\end{align}\]

where $\odot$ is the Hademard (element-wise) product of an appropriately expanded[fn:2] parameter vector, e.g. so that in the first instance, each element of $\bA$ corresponding to an element of $E$ is multiplied by $\tau_E$, and similarly for $I$.

* Simulation
** Overview
The code is outlined as follows

#+BEGIN_SRC julia :noweb no-export :results silent :tangle WC73.jl
  module WC73
  <<load-modules>>
  <<parameters-loader>>
  <<wc73-definition>>
  <<wc73-solver>>
  <<wc73-analysis>>
  export load_WilsonCowan73_parameters, solve_WilsonCowan73
  end
#+END_SRC

The test cases (written here alongside the functions they test) are tangled into
a separate file.
#+BEGIN_SRC julia :noweb no-export :tangle test_wilson-cowan.jl
using Base.Test
include("./wilson-cowan.jl")
<<wc73-definition-test>>
#+END_SRC

See the appendix for helper functions, including parameter loading.

** Imports

#+BEGIN_SRC julia :noweb-ref load-modules :results silent
  using Parameters
  import JSON

  using TensorOperations

  using DifferentialEquations

  import Base.Dates

  push!(LOAD_PATH, joinpath(ENV["HOME"], "gits", "simulation-73"))
  using SimulationTypes

#+END_SRC

** Define WilsonCowan73
*** Overview
I will relegate the sigmoid and input functions to the appendix. Suffice to say,
the sigmoid is rectified and normed, and the input function is a step function
centered at $x=0$.

#+BEGIN_SRC julia :noweb no-export :noweb-ref wc73-definition :results silent
  <<wc73-types>>
  <<sigmoid>>
  <<stimulus>>
  <<connectivity>>
  <<wc73-constructor>>
  <<wc73-differential>>
#+END_SRC

#+BEGIN_SRC julia :noweb-ref wc73-definition-test
<<sigmoid-test>>
<<stimulus-test>>
<<connectivity-test>>
#+END_SRC

*** Model parameter struct definition
The input parameters are defined in another file, for ease of modification and
testing. Here we define the actual model parameters that are held by the
solver. The the "explicit fields" that form the first section of
the below parameter struct are explicitly included in the input parameters. The
later parameters are not explicitly included, but are calculated from input
parameters. The comments describe other input parameters that are not relevant
to this parameter struct.
#+BEGIN_SRC julia :noweb-ref wc73-types
  @with_kw struct WilsonCowan73Params{InteractionType, ParamType}
    # Explict fields in parameter file
    # May also be given as LaTeX command (e.g. alpha for α)
      α::ParamType     # Weight on homeostatic term
      β::ParamType     # Weight on nonlinear term
      τ::ParamType     # Time constant
      a::ParamType     # Sigmoid steepness
      θ::ParamType     # Sigmoid translation
      r::ParamType     # Refractory period multiplier
    # Other fields in parameter file include
    # :time => {[:N], :extent}
    # :space => {:N, :extent}
    # :stimulus => {:weight, :duration, :strength}
    # :connectivity => {:amplitudes, :spreads}
    # Constructed fields
      W::InteractionType    # Tensor interaction multiplier
      stimulus_fn::Function
      mesh::AbstractMesh
  end
#+END_SRC

*** Constructor for WC73 parameter object

To construct the above model parameter struct, the explicit params are expanded
to be of the same length as the model value (1x2 -> nx2). I'm not sure this is a
good idea for speed, but it makes the code more robust so that broadcasting
never expands the parameter in the wrong direction.

In addition to expanding the explicit parameters, the calculated "parameters" are
calculated. Notice that one is a struct and another is a function, which
hopefully does not break the automatic differentiation of
DifferentialEquations for the other parameters. I haven't checked.
#+BEGIN_SRC julia :noweb-ref wc73-constructor

    function WilsonCowan73Params(p)
        p = deepcopy(p) # to prevent mutation
        npops = length(p[:r])

        space_dims = pop!(p, :space)
        @assert length(space_dims) == 1      # Currently only supports 1D
        mesh = PopMesh(space_dims, npops)
        if ndims(mesh) == 2
            mesh = flatten(mesh)
        end
        @assert mesh isa FlatMesh

        stimulus_params = expand_params(mesh, pop!(p, :stimulus))
        connectivity_params = expand_params(mesh, pop!(p, :connectivity))
        p = expand_params(mesh, p)

        p[:mesh] = mesh
        p[:stimulus_fn] = make_stimulus_fn(mesh; stimulus_params...)
        p[:W] = sholl_connectivity(mesh, connectivity_params[:amplitudes],
                                   connectivity_params[:spreads])

        return WilsonCowan73Params(; p...)
    end

  function expand_params(mesh::AbstractMesh, dct::T) where T <: Dict
      for (k,v) in dct
          if v isa PopulationParam
              dct[k] = expand_param(mesh, v)
          end
      end
      return dct
  end

#+END_SRC

*** Differential equation definition
Two versions of the differential equation function, both implementing the same
equation described in the Equations section. One is general, putatively
operating on any number of populations (though must still be 1D!). It is much
less efficient in the 2-pop case than the latter, which takes a matrix instead
of a tensor as the interaction term.
#+BEGIN_SRC julia :noweb-ref wc73-differential

  WilsonCowan73!(dA,A::SpaceState1D,p::WilsonCowan73Params{InteractionTensor},t) = begin
      # Use dA as intermediate variable for tensor op since it is preallocated
      @tensor dA[x_tgt, pop_tgt] = p.W[x_tgt, pop_tgt, x_src, pop_src] * A[x_src, pop_src]
      dA .= (-p.α .* A + p.β .* (1 .- A) .* sigmoid_fn(dA + p.stimulus_fn(t), p.a, p.θ)) ./ p.τ
  end

  WilsonCowan73!(dA,A::SpaceState1DFlat,p::WilsonCowan73Params{Interaction1DFlat},t) = begin
      # Use dA as intermediate variable for tensor op since it is preallocated
      dA .= (-p.α .* A + p.β .* (1 .- A) .* sigmoid_fn(p.W*A + p.stimulus_fn(t), p.a, p.θ)) ./ p.τ
  end
#+END_SRC

** WilsonCowan73 Solver

#+BEGIN_SRC julia :noweb-ref wc73-solver

  function solve_WilsonCowan73(; model=nothing, solver=nothing, other...)
      solver_params = deepcopy(Dict{Any,Any}(solver))
      model_params = WilsonCowan73Params(model)

      u0 = zeros(model_params.mesh)
      tspan = (0.0, pop!(solver_params, :T))
      prob::DEProblem = ODEProblem(WilsonCowan73!, u0, tspan, model_params)

      if :dt in keys(solver_params)
          solver_params[:alg] = Euler()
          solver_params[:adaptive] = false
      elseif :stiff in keys(solver_params)
          if pop!(solver_params, :stiff) > 0
              solver_params[:alg_hints] = [:stiff]
          end
      end

      if :stiff in keys(solver_params)
          error("Incompatible solver parameters.")
      end

      soln::DESolution = solve(prob; solver_params...)

      return soln
  end

#+END_SRC

* Appendix
** Parameter file reading
Because I originally wrote this in Python, the parameter files are JSON. (In the
process of moving to fully Julia parameters).
#+BEGIN_SRC julia :noweb-ref parameters-loader :results silent
  function convert_py(val::Number)
      float(val)
  end

  function convert_py(a::T) where T <: Array
      if a[1] isa Array && a[1][1] isa Number # eltype gives Any, for some reason
          return InteractionParam(vcat([convert_py(arr) for arr in a]...))
      elseif a[1] isa Dict
          return convert_py.(a)
      elseif a[1] isa Number
          return PopulationParam(convert_py.(vcat(a...))) # Python arrays are rows...
      else
          error("Unsupported parse input array of eltype $(typeof(a[1]))")
      end
  end

  convert_py(val::String) = val

  function convert_py(d::T) where T <: Dict
      # TODO: Find package that does this...
      unicode_dct = Dict(:alpha=>:α, :beta=>:β, :tau=>:τ, :theta=>:θ)
      function convert_pykey(k_sym::Symbol)
          if k_sym in keys(unicode_dct)
              return unicode_dct[k_sym]
          else
              return k_sym
          end
      end
      convert_pykey(k::String) = (convert_pykey ∘ Symbol)(k)

      return Dict(convert_pykey(k) => convert_py(v) for (k,v) in d)
  end

  function deep_merge(dct1, dct2::D) where D <: Dict
      new_dct = deepcopy(dct1)
      for k in keys(dct2)
          if k in keys(dct1)
              new_dct[k] = deep_merge(dct1[k], dct2[k])
          else
              new_dct[k] = dct2[k]
          end
      end
      return new_dct
  end
  function deep_merge(el1, el2)
      return el2
  end
  function deep_merge(el1, void::Void)
      return el1
  end
  function load_WilsonCowan73_parameters(json_filename::String, modifications=nothing)
      # Parse JSON with keys as symbols.
      param_dct = (convert_py ∘ JSON.parsefile)(json_filename)
      return deep_merge(param_dct, modifications)
  end

#+END_SRC

#+RESULTS:
#+begin_example
convert_py (generic function with 1 method)

parse_pykey (generic function with 1 method)

parse_pyvalue (generic function with 1 method)

parse_pyarray (generic function with 1 method)

parse_py_dict (generic function with 1 method)

load_WilsonCowan73_parameters (generic function with 1 method)
#+end_example

** Sigmoid

The sigmoid function is defined
\[\begin{align}
\sigmoid(x) = \frac{1}{1 + \exp(-a(x - \theta))}
\end{align}\]
where $a$ describes the slope's steepness and $\theta$ describes translation of the slope's center away from zero.

The current definition uses a macro. It is not clear that this is necessary, nor even advisable. However, the ParameterizedFunction automatically calculates useful quantities like the Jacobian, including with respect to the parameters themselves, and I thought I'd see if this works better. Initially I was using a provided macro that didn't seem to like function calls, so this macro was necessary. Now I doubt it's necessary and I'll probably run some tests to see if there's any performance difference in the DifferentialEquations solve.

#+BEGIN_SRC julia :noweb-ref sigmoid :results silent
  function simple_sigmoid_fn(x, a, theta)
      return @. (1 / (1 + exp(-a * (x - theta))))
  end

  function sigmoid_fn(x, a, theta)
      return max.(0, simple_sigmoid_fn(x, a, theta) .- simple_sigmoid_fn(0, a, theta))
  end
#+END_SRC

*** Test

#+BEGIN_SRC julia :noweb-ref sigmoid-test
  import WC73: simple_sigmoid_fn, sigmoid_fn
  @testset "Sigmoids" begin
      @test simple_sigmoid_fn(0,1,0) == 0.5
      @test simple_sigmoid_fn(0,1,0.5) ≈ 0.37754066879814
      @test simple_sigmoid_fn(1,1,1) == 0.5
      @test sigmoid_fn(0,1,0) == 0.0
      @test sigmoid_fn(0,1,0.5) == 0.0
      @test sigmoid_fn(1,1,1) ≈ 0.231058578630049
  end
#+END_SRC

** Connectivity
#+BEGIN_SRC julia :noweb-ref connectivity :results silent
<<connectivity-distance-matrix>>
<<connectivity-sholl-matrix>>
<<connectivity-sholl>>
#+END_SRC

#+BEGIN_SRC julia :noweb-ref connectivity-test
  @testset "Connectivity" begin
      <<connectivity-distance-matrix-test>>
      <<connectivity-sholl-matrix-test>>
      <<connectivity-sholl-test>>
  end
#+END_SRC
*** Sholl's exponential decay
We use an exponential connectivity function, inspired both by Sholl's
experimental work, and by certain theoretical considerations.
#+BEGIN_SRC julia :noweb-ref connectivity-sholl-matrix :results silent
  function sholl_matrix(amplitude::NumType, spread::NumType,
                        dist_mx::Array{NumType,2}, step_size::NumType)
      conn_mx = @. amplitude * step_size * exp(
          -abs(dist_mx / spread)
      ) / (2 * spread)
      return conn_mx
  end
#+END_SRC
The interaction between two populations is entirely characterized by this
function and its two parameters: the amplitude (weight) and the spread
(σ). The spatial step size is also a factor, but as a computational concern
rather than a fundamental one.
**** Test
#+BEGIN_SRC julia :noweb-ref connectivity-sholl-matrix-test
  import WC73: sholl_matrix, distance_matrix
  @testset "Sholl Matrix" begin
      xs = linspace(-1.0,1.0,3)
      @test all(.≈(sholl_matrix(1.0, 1.0, distance_matrix(xs), step(xs)), [0.5         0.18393972  0.06766764;
                                                 0.18393972  0.5         0.18393972;
                                                 0.06766764  0.18393972  0.5       ], atol=1e-6))
  end
#+END_SRC

*** Make matrix of all inter-point distances
This matrix contains values such that the $j^{th}$ column of the $i^{th}$ row
contains the distance between locations $i$ and $j$ in the 1D space dimension provided.
#+BEGIN_SRC julia :noweb-ref connectivity-distance-matrix :results silent
  function distance_matrix(xs::SpaceDim)
      # aka Hankel, but that method isn't working in SpecialMatrices
      distance_mx = zeros(eltype(xs), length(xs), length(xs))
      for i in range(1, length(xs))
          distance_mx[:, i] = abs.(xs - xs[i])
      end
      return distance_mx'
  end
#+END_SRC

**** Test
#+BEGIN_SRC julia :noweb-ref connectivity-distance-matrix-test
  @testset "Distance Matrix" begin
      @test_skip true
  end
#+END_SRC

*** Join Sholl matrices into complete interaction tensor
This calculates a matrix of Sholl's exponential decay for each pair of
populations, thus describing all pairwise interactions. The result is a tensor
describing the effect of the source population at one location on the target
population in another location (indexed: [tgt_loc, tgt_pop, src_loc,
src_pop]). This works for arbitrarily many populations (untested) but only for
1D space.
#+BEGIN_SRC julia :noweb-ref connectivity-sholl :results silent
      function sholl_connectivity(mesh::PopMesh, W::Array{NumType,2},
				  Σ::Array{NumType,2})::InteractionTensor
	  xs = mesh.space.dims[1]
	  N_x = length(xs)
	  N_pop = size(W)[1]
	  conn_tn = zeros(N_x, N_pop, N_x, N_pop)
	  for tgt_pop in range(1,N_pop)
	      for src_pop in range(1,N_pop)
		  conn_tn[:, tgt_pop, :, src_pop] .= sholl_matrix(W[tgt_pop, src_pop],
				Σ[tgt_pop, src_pop], distance_matrix(xs), step(xs))
	      end
	  end
	  return conn_tn
      end
      <<connectivity-flatten-sholl>>
#+END_SRC

**** Test
#+BEGIN_SRC julia :noweb-ref connectivity-sholl-test
   import WC73: sholl_connectivity, PopMesh, flatten
   @testset "Sholl tensor" begin
         weights = [1.0 2.0; 3.0 4.0]
         spreads = [0.1 0.2; 0.3 0.4]
         mesh = PopMesh([Dict(:N => 3, :extent => 2)], 2)
         observed = sholl_connectivity(flatten(mesh), weights, spreads)
         expected =      [  5.00000000e+00   2.26999649e-04   1.03057681e-08   5.00000000e+00   3.36897350e-02   2.26999649e-04 ;
   2.26999649e-04   5.00000000e+00   2.26999649e-04   3.36897350e-02   5.00000000e+00   3.36897350e-02 ;
   1.03057681e-08   2.26999649e-04   5.00000000e+00   2.26999649e-04   3.36897350e-02   5.00000000e+00 ;
  5.          0.17836997  0.00636317  5.          0.41042499  0.03368973 ;
  0.17836997  5.          0.17836997  0.41042499  5.          0.41042499 ;
  0.00636317  0.17836997  5.          0.03368973  0.41042499  5.         ]
         println(observed)
         @test all(.≈(observed, expected, atol=1e-6))
   end
#+END_SRC
*** Flatten 1-space-D Sholl tensor
In the two population case, flattening the tensor and using matrix
multiplication is 3x faster. The below provides exactly that.
#+BEGIN_SRC julia :noweb-ref connectivity-flatten-sholl
  function sholl_connectivity(mesh::FlatMesh, args...)
      sholl_connectivity(unflatten(mesh), args...) |> flatten_sholl
  end
  function flatten_sholl(tensor)::Interaction1DFlat
      N_x, N_p = size(tensor)[1:2]
      @assert N_p < N_x
      @assert size(tensor) == (N_x, N_p, N_x, N_p)
      flat = zeros(eltype(tensor), N_x*N_p, N_x*N_p)
      for i in 1:N_p
          for j in 1:N_p
              flat[(1:N_x)+((i-1)*N_x), (1:N_x)+((j-1)*N_x)] = tensor[:,i,:,j]
          end
      end
      return flat
  end
#+END_SRC

** Stimulus

This is a factory which takes the name of a stimulus and returns the function
defined to be associated with that name. The stimulus returned is a function of
time only.
#+BEGIN_SRC julia :noweb-ref stimulus :results silent
  function make_stimulus_fn(mesh; name=nothing, args...)
      stimulus_factories = Dict(
          "smooth_bump" => smooth_bump_factory,
          "sharp_bump" => sharp_bump_factory
      )
      return stimulus_factories[name](mesh; args...)
  end
#+END_SRC

#+BEGIN_SRC julia :noweb-ref stimulus-test
  @testset "Stimulus" begin
      @test_skip true
  end
#+END_SRC

*** Smooth bump (like Gaussian)
The smooth bump is a smooth approximation of the sharp impulse defined
elsewhere. It is smooth in both time and space. It is constructed essentially
from three sigmoids: Two coplanar in space, and one orthogonal to those in
time. The two in space describe a bump: up one sigmoid, then down a negative
sigmoid. The one in time describes the decay of that bump.

This stimulus has the advantages of being 1) differentiable, and 2) more
realistic. The differentiabiilty may be useful for the automatic solvers that
Julia has, which can try to automatically differentiate the mutation function
in order to improve the solving.
#+BEGIN_SRC julia :noweb-ref stimulus :results silent
  function make_smooth_bump_frame(mesh_coords::Array{DistType}, width::DistType, strength::NumType, steepness::NumType)
      @. strength * (simple_sigmoid_fn(mesh_coords, steepness, -width/2) - simple_sigmoid_fn(mesh_coords, steepness, width/2))
  end

  function smooth_bump_factory(mesh::AbstractMesh;
                               width=nothing, strength=nothing, duration=nothing,
                               steepness=nothing)
      # WARNING: Defaults are ugly; Remove when possible.
      on_frame = make_smooth_bump_frame(coords(mesh), width, strength, steepness)
      return (t) -> @. on_frame * (1 - simple_sigmoid_fn(t, steepness, duration))
  end
#+END_SRC

*** Sharp bump (Heaviside)
The "sharp bump" is the usual theoretical impulse: Binary in both time and
space. On, then off.
#+BEGIN_SRC julia :noweb-ref stimulus :results silent
  function make_sharp_bump_frame(mesh::PopMesh, width::DistType, strength::NumType)
      mesh_coords = coords(mesh)
      frame = zeros(mesh_coords)
      mid_point = 0     # half length, half width
      half_width = width / 2      # using truncated division
      xs = mesh_coords[:,1]   # Assumes all pops have same mesh_coords
      start_dx = find(xs .>= mid_point - half_width)[1]
      stop_dx = find(xs .<= mid_point + half_width)[end]
      frame[start_dx:stop_dx,:] = strength
      return frame
  end
  function make_sharp_bump_frame(mesh::FlatMesh, args...)
      structured_frame = make_sharp_bump_frame(mesh.pop_mesh, args...)
      flat_frame = structured_frame[:] # Works because FlatMesh must have 1D PopMesh
      return flat_frame
  end
  function sharp_bump_factory(mesh; width=nothing, strength=nothing, duration=nothing)
          # WARNING: Defaults are ugly; Remove when possible.
      on_frame = make_sharp_bump_frame(mesh, width, strength)
      off_frame = zeros(on_frame)
      return (t) -> (t <= duration) ? on_frame : off_frame
  end
#+END_SRC
* Footnotes

[fn:2] Under the tensor notation, this is merely broadcasting.

[fn:1] It will be more natural (and likely extensible) to concatenate along the second dimension, as done in the previous Python implementation. Here I restrict myself to vertical concatenation to avoid muddling things with the introduction of tensor multiplication and Einstein notation.
